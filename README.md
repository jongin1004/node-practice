# NODE 
자바스크립트를 사용하여 서버 측 애플리케이션을 개발할 수 있도록 도와주는 런타임 환경입니다. Node.js는 웹 브라우저가 아닌 서버에서 JavaScript 코드를 실행할 수 있도록 하는 것을 목표로 만들어진 개발 플랫폼

**V8 엔진** 
Node.js는 Google의 V8 엔진을 기반으로 하는 JavaScript 런타임입니다. 이 엔진은 JavaScript 코드를 컴퓨터가 이해할 수 있는 기계 코드로 변환합니다. V8이 없으면 Node는 우리가 작성한 JavaScript 코드를 이해할 수 없을 것입니다.

**libuv** 
libuv는 비동기 I/O에 중점을 둔 오픈 소스 라이브러리입니다. 이 라이브러리는 Node에게 하부 컴퓨터 운영 체제, 파일 시스템, 네트워킹 등에 대한 액세스를 제공합니다. 또한 libuv는 Node.JS의 **이벤트 루프**와 **스레드 풀**이라는 두 가지 매우 중요한 기능을 구현합니다.

또한 Node.js 엔진은 V8 엔진과 libuv 뿐만 아니라 여러 다른 라이브러리도 활용합니다.

**http-parser:** HTTP 파싱을 위한 라이브러리입니다.
**c-ares:** DNS 요청 처리를 위한 라이브러리입니다.
**OpenSSL:** 암호화를 위한 라이브러리입니다.
**zlib:** 압축을 위한 라이브러리입니다.

Node.js는 단일 스레드이다.
여러 사용자가 애플리케이션에 접근하더라도 단일 스레드에서 실행되므로 블로킹을 피해야 합니다.
(블로킹: 코드가 동기적으로 실행됐을 때, 현재 코드가 실행이 끝날 때까지 다음코드는 기다려야함)

Node 애플리케이션이 시작될 때 초기화 단계가 진행됩니다. 최상위 코드가 실행되며, 필요한 모듈이 로드되고, 콜백 함수가 등록됩니다.
이후 이벤트 루프가 시작됩니다. 이벤트 루프는 애플리케이션의 대부분 작업이 처리되는 곳으로, Node 아키텍처의 핵심입니다.
그러나 일부 무거운 작업은 이벤트 루프에서 처리하기에는 너무 비용이 많이 듭니다. 이러한 작업을 처리하기 위해 스레드 풀이 사용됩니다.

스레드 풀은 주 스레드와 별도로 제공되는 추가적인 스레드입니다. 보통 4개의 스레드로 구성되지만 최대 128개의 스레드까지 설정할 수 있습니다.
스레드 풀은 파일 작업, 암호화, 압축 작업, DNS 조회와 같이 무거운 작업을 처리합니다.

### 요약
Node.js는 단일 스레드에서 실행되며, 주 스레드를 블로킹하지 않기 위해 이벤트 루프와 스레드 풀을 사용하여 작업을 분산 처리합니다. 이를 통해 동시에 여러 작업을 효율적으로 처리할 수 있도록 합니다.

## 이벤트 루프
Node.js 프로세스 내에서 실행되며, 콜백 함수 내의 응용 프로그램 코드가 실행된다. 
콜백함수를 포함하는 모든 코드는 이벤트 루프에서 실행되기 때문에, Node 아키텍처의 가장 핵심이라고 할 수 있다.

### 이벤트 루프의 4단계
타이머 만료 콜백 처리: setTimeout() 함수와 같이 타이머에서 만료된 콜백을 처리합니다.
I/O 폴링 및 I/O 콜백 실행: 네트워킹 및 파일 액세스와 같은 I/O 작업이 주로 처리되는 단계입니다.
setImmediate 콜백 처리: I/O 폴링 및 I/O 콜백 단계 이후에 바로 실행되어야 하는 콜백을 처리합니다.
close 콜백 처리: 웹 서버나 웹 소켓이 종료될 때 close 이벤트를 처리합니다.

각각의 단계는 콜백 큐를 가지고 있어, 순차적인 처리를 한다. 

또한, 위의 4개의 콜백 큐를 제외하고도 NEXTTICK() 큐와 MICROTASKS 큐를 가지고있다. 

### 이벤트 루프의 동작
이벤트 루프는 하나의 사이클(틱)에서 동작합니다.
각 단계에서 콜백 큐에 있는 콜백이 하나씩 처리됩니다.
네 가지 단계가 끝난 후 다음 틱으로 진행할지 종료할지 결정됩니다.
(하나의 사이클이 완료하게 되면, 실행중인 타이머나 스레드 풀을 확인해 없으면 종료 있으면 다음 사이클을 실행)

### Node 개발시 주의점
이벤트 루프를 블로킹하지 않도록 주의해야 합니다.
동기적인 함수와 복잡한 계산을 이벤트 루프에서 피해야 합니다.
JSON 파싱 및 문자열 변환에서 성능 문제를 유의해야 합니다.
복잡한 정규 표현식 사용을 피해야 합니다
(싱글 스레드인 Node의 블로킹을 막기위함)

**스레드 풀**
파일 액세스, 압축 등과 같은 더 무거운 작업을 처리하는 역할을 합니다.

##

## Node.js가 왜 백엔드 개발에 좋은지
응용 프로그램이 빠르고 확장이 가능하다. 
이벤터 기반의 단일 스레드, 비블럭 I/O모델 

### 블럭 VS 비블럭
간단히, 동기화의 방식이 블럭이라고 볼 수 있다. 
코드에서 라인 순차적으로 코드가 실행되고, 이전 라인의 코드의 실행이 끝나야지만 다음 라인의 코드가 실행 될 수 있다. 따라서, 이전 라인의 코드 실행이 종료되지 않으면 다음 코드는 실행되지 않는 블럭 상태가 된다. 

반대로, 비동기화 방식은 논블럭이다. 
이전 라인의 코드 실행이 종료되는 것을 기다리지 않고, 코드는 백그라운드에서 실행을 시키면서, 다음 라인의 코드 실행을 진행한다. 

Node는 싱글 스레드이기 때문에, Node.js 프로세스에서는 모든 유저를 단일 스레드에서 처리한다.
다른 사람의 코드가 동기적으로 실행되게되면, 블럭이되어 다른 사람들도 기다려야만 하기 때문에, 비동기적으로 실행되어야한다. 

데이터베이스 기반의 API, 데이터 스트리밍, 실시간 채팅, 서버사이드 앱등 활용이 가능하다. 
단, 서버 측의 프로세싱 작업이 주가되는 곳에는 사용할 수 없다. (이미지 처리등)


## npm
npm(Node Package Manager)은 자바스크립트 기반의 패키지 관리자로서, Node.js 환경에서 프로젝트의 의존성을 관리하고 패키지를 설치하고 공유할 수 있게 해주는 도구입니다.

### npm의 기능과 역할

**패키지 관리:** npm은 프로젝트의 의존성 패키지를 관리하는 데 사용됩니다. 프로젝트에서 필요한 외부 라이브러리나 모듈을 간단하게 설치하고 관리할 수 있습니다.

**패키지 설치:** npm install 명령을 사용하여 패키지를 설치할 수 있습니다. 이때 프로젝트의 package.json 파일에 정의된 의존성 정보를 바탕으로 패키지가 설치됩니다.

**패키지 버전 관리:** package.json 파일에는 프로젝트의 의존성 패키지와 해당 버전 정보가 기록됩니다. 이를 통해 프로젝트의 모든 개발자가 동일한 버전의 패키지를 사용할 수 있습니다.

**스크립트 실행:** package.json 파일에 스크립트를 등록하여 프로젝트에서 자주 사용하는 작업을 간단하게 실행할 수 있습니다. 예를 들어, 개발 서버 실행, 빌드 등의 작업을 스크립트로 등록하여 편리하게 실행할 수 있습니다.

**전역 설치:** 패키지를 전역적으로 설치하면 터미널에서 해당 패키지의 명령을 어디서든 사용할 수 있습니다. npm install -g 명령으로 전역 설치할 수 있습니다.

**npm 레지스트리:** npm 레지스트리는 수많은 오픈 소스 패키지들이 등록되어 있는 중앙 저장소입니다. 이 레지스트리에서 필요한 패키지를 검색하고 설치할 수 있습니다.

### Semantic Versioning
npm에서 버전을 표현하는 방식으로, 버전 번호를 통해 소프트웨어의 변경 사항을 명확하게 표현하기 위한 규칙을 제공 

**1.3.4**와 같이 표현하며, 각각의 위치에 따라 의미하는 것이 다르다.

**메이저 버전 (Major Version):** 첫 번째 숫자는 메이저 버전을 나타냅니다. 이 버전 숫자는 하위 호환되지 않는 변경사항이 있는 경우에 올라가게 됩니다. 즉, API의 큰 변화나 기능적으로 업그레이드한 경우에 메이저 버전이 올라갑니다.

**마이너 버전 (Minor Version):** 두 번째 숫자는 마이너 버전을 나타냅니다. 마이너 버전은 하위 호환성을 유지하면서 기능이 추가되거나 변경된 경우에 올라가게 됩니다. 즉, 기능이 추가되었지만 이전 버전과 호환되는 경우에 마이너 버전이 올라갑니다.

**패치 버전 (Patch Version):** 세 번째 숫자는 패치 버전을 나타냅니다. 패치 버전은 기능적으로 변경이 없지만 버그 수정이나 작은 수정이 이루어진 경우에 올라가게 됩니다.

### versioning
package.json파일에서는 버전앞에 특수 문자를 이용해 패키지의 버전을 지정할 수 있다.

**^:** caret 기호는 주 버전 변경이 없을 때에만 업데이트되도록 지정합니다. 

"^1.2.3": 1.2.3 버전부터 2.0.0 미만의 모든 버전을 포함하는 범위를 의미합니다. 주 버전이 1인 경우, 패치와 마이너 버전 업데이트가 가능합니다.

**~:** tilde 기호는 주 버전과 마이너 버전 변경이 없을 때에만 업데이트되도록 지정합니다.

"~1.2.3": 1.2.3 버전부터 1.3.0 미만의 모든 버전을 포함하는 범위를 의미합니다. 주 버전과 마이너 버전이 1.2인 경우, 패치 버전 업데이트가 가능합니다.

***:** 별표는 어떤 버전이든지 상관없이 모든 버전을 허용합니다.

"*": 어떤 버전이든 상관없이 모든 버전을 허용합니다.

**빈 문자열 ("")**: 빈 문자열은 어떤 버전이든 상관없이 모든 버전을 허용하는 것과 같습니다.

**>:** 주어진 버전보다 큰 버전을 선택합니다.

"dependencies": { "package-name": ">1.2.3" }: 1.2.3 버전보다 큰 모든 버전을 포함합니다.

**<:** 주어진 버전보다 작은 버전을 선택합니다.

"dependencies": { "package-name": "<2.0.0" }: 2.0.0 버전 미만의 모든 버전을 포함합니다.

**>=:** 주어진 버전 이상의 버전을 선택합니다.

"dependencies": { "package-name": ">=1.5.0" }: 1.5.0 버전 이상의 모든 버전을 포함합니다.

**<=:** 주어진 버전 이하의 버전을 선택합니다.

"dependencies": { "package-name": "<=3.2.1" }: 3.2.1 버전 이하의 모든 버전을 포함합니다.